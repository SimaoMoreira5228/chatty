#![forbid(unsafe_code)]

use std::path::Path;
use std::{env, fs};

use chatty_util::endpoint::validate_quic_endpoint;

/// Build-time default server endpoint (`quic://host:port`).
const ENV_ENDPOINT: &str = "CHATTY_SERVER_ENDPOINT";

fn main() {
	println!("cargo:rerun-if-env-changed={ENV_ENDPOINT}");

	let profile = env::var("PROFILE").unwrap_or_else(|_| "debug".to_string());
	let endpoint = env::var(ENV_ENDPOINT).ok();

	let endpoint = match (profile.as_str(), endpoint) {
		("release", None) => {
			panic!(
				"{ENV_ENDPOINT} must be set for release builds.\n\
				 Expected format: quic://host:port\n\
				 Example:\n\
				 \t{ENV_ENDPOINT}=quic://chatty.example.com:443 cargo build -p chatty_client_gpui --release\n"
			);
		}
		(_, Some(v)) => {
			let v = v.trim().to_string();
			if v.is_empty() {
				panic!("{ENV_ENDPOINT} was set but empty; expected format: quic://host:port");
			}
			validate_quic_endpoint(&v).unwrap_or_else(|e| {
				panic!("{ENV_ENDPOINT} is invalid: {e}\nExpected format: quic://host:port");
			});
			v
		}
		(_, None) => "quic://127.0.0.1:18203".to_string(),
	};

	let out_dir = env::var("OUT_DIR").expect("OUT_DIR is set by Cargo");
	let dest_path = Path::new(&out_dir).join("server_endpoint.rs");

	let contents = format!(
		"// @generated by build.rs â€” do not edit by hand.\n\
		 // Default server endpoint baked into this build.\n\
		 pub const DEFAULT_SERVER_ENDPOINT: &str = {endpoint:?};\n\
		 // Whether the server endpoint is locked (release builds only).\n\
		 pub const SERVER_ENDPOINT_LOCKED: bool = {locked};\n",
		locked = profile.as_str() == "release"
	);

	fs::write(&dest_path, contents).expect("write generated server endpoint file");
}
